{
    "0" : {
        "tags" : ["ALL", "ВСЕ"],
        "body" : [
                "<b>Все, что есть в базе:</b>\n",
                "\nGlobals: <u>100%</u>",
                "\n<blockquote expandable>GDScript, GlobalScope</blockquote>",
                "\n\nНоды: <u>8%</u>",
                "\n<blockquote expandable>Node, AcceptDialog, AnimatableBody2D, AnimatableBody3D, AnimatedSprite2D, AnimatedSprite3D, AnimationMixer, AnimationPlayer, AnimationTree, Area2D, Area3D, AspectRatioContainer, AudioLister2D, AudioLister3D, AudioStreamPlayer, AudioStreamPlayer2D, AudioStreamPlayer3D, BackBufferCopy, BaseButton, Bone2D</blockquote>",
                "\n\nРесуры: <u>0%</u>\n\nПрочие объекты: <u>0%</u>\n\nДоступные из редактора: <u>0%</u>\n\nРазличные типы: <u>100%</u>",
                "\n<blockquote expandable>Variant, AABB, Array, Basis, bool, Callable, Color, Dictionaty, float, int, NodePath, Object, PackedByteArray, PackedColorArray, PackedFloat32Array, PackedFloat64Array, PackedInt32Array, PackedInt64Array, PackedStringArray, PackedVector2Array, PackedVector3Array, PackedVector4Array, Plane, Projection, Quanternion, Rect2, Rect2i, RID, Signal, String, StringName, Transform2D, Transform3D, Vector2, Vector2i, Vector3, Vector3i, Vector4, Vector4i</blockquote>"
        ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/index.html#"
        }
    },
    "1" : {
        "tags" : ["VARIANTS", "TYPES", "ТИПЫ", "ПЕРЕМЕННАЯ", "ПЕРЕМЕННЫЕ", "VARIABLES", "VARUABLES", "ПИРИМЕННАЯ", "ПИРИМЕНАЯ"],
        "body" : [
                "<b>Различные типы</b>\n",
                "\nТипы переменных — это категории, которые определяют, какие данные может хранить переменная и какие операции можно с ними выполнять.\n",
                "<blockquote expandable><b>Примечание:</b> Godot Engine может использовать как динамические типы (Godot определит их за вас), так и статические типы (указать заранее)</blockquote>",
                "\n\n<b>Список всех возможных типов в Godot:</b>",
                "\n\nVariant, AABB, Array, Basis, bool, Callable, Color, Dictionaty, float, int, NodePath, Object, PackedByteArray, PackedColorArray, PackedFloat32Array, PackedFloat64Array, PackedInt32Array, PackedInt64Array, PackedStringArray, PackedVector2Array, PackedVector3Array, PackedVector4Array, Plane, Projection, Quanternion, Rect2, Rect2i, RID, Signal, String, StringName, Transform2D, Transform3D, Vector2, Vector2i, Vector3, Vector3i, Vector4, Vector4i",
                "\n\n<b>Краткие примеры:</b>",
                "\n<pre><code class='language-GDScript'>var x: int = 10 # Статическая переменная,\n содержащая целочисленное значение 10\nvar y: float = 10.5 # Статическая переменная,\n содержащая дробное значение 10.5\nvar z = 'Hello world' # Динамическая переменная,\n содержащая буквенные литералы</code></pre>"
        ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/en/stable/classes/index.html#variant-types"
        }
    },
    "2" : {
        "tags" : ["VARIANT", "ВАРИАНТ", "ВАРИАНТЫ", "VAR", "ВАР"],
        "body" : [
                "<b>Variant</b>\n",
                "\nVariant — это наиболее важный тип данных в Godot. Variant занимает всего 24 байта на 64-битных платформах (20 байт на 32-битных платформах) и может хранить в себе практически любой тип данных движка. Варианты редко используются для хранения информации в течение длительного времени, вместо этого они применяются в основном для передачи, редактирования, сериализации и перемещения данных",
                "\n<blockquote expandable>В компьютерном программировании класс Variant — это класс, предназначенный для хранения данных различных типов. Динамические языки программирования, такие как PHP, Lua, JavaScript и GDScript, используют их для хранения данных переменных на сервере. С помощью этих вариантов свойства могут свободно менять типы значений.</blockquote>",
                "\n<pre><code class='language-GDScript'>var foo = 2 # foo - это динамическое целое число\nfoo = 'Now foo is a string!'\nfoo = RefCounter.new() # теперь foo - это объект\nvar bar: int = 2 # bar — это целое число со статической типизацией.\n# bar = 'Ой-ой-ой! Я не могу заставить статически типизированные переменные стать другого типа!'</code></pre>",
                "\nGodot отслеживает все переменные API скриптов в рамках Variants. Вы даже не осознаёте, что постоянно используете Variants. Когда конкретный язык применяет собственные правила для типизации данных, он использует собственную логику поверх базового API скриптов Variants.",
                "\n<blockquote expandable>GDScript автоматически преобразует значения в них. По умолчанию все данные хранятся в виде простых вариантов, а затем, при необходимости, применяются пользовательские правила статического типизации для типов переменных.</blockquote>",
                "\n\nГлобальная функция <code>GlobalScope.typeof</code> возвращает перечисляемое значение типа Variant, хранящееся в текущей переменной (см. типы переменных).",
                "\n<pre><code class='language-GDScript'>var foo = 2\nmatch typeof(foo):\n   TYPE_NIL: print('foo является нуль')\nTYPE_INT: print('foo - целое число)\nTYPE_OBJECT:\n   #Обратите внимание, что объекты представляют собой отдельную категорию.\n   #Чтобы получить имя базового типа объекта, вам понадобится метод `get_class()`\n   print('foo is a(n) %s' % foo.get_class())</code></pre>"
        ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/en/stable/classes/class_variant.html"
        }
    },
    "3" : {
        "tags" : ["AABB", "ААББ"],
        "body" : [
                "<b>AABB</b>\n",
                "\nВстроенный тип AABB Variant* представляет собой ограничивающую рамку, выровненную по осям в трёхмерном пространстве. Определяется положением и размером, которые являются Vector3. Используется для быстрого тестирования на пересечение (см. intersects()). Хотя AABB сама по себе выровнена по осям, её можно комбинировать с Transform3D, чтобы представить повернутую или перекошенную ограничивающую рамку.",
                "\n\n<blockquote expandable><b>Примечание:</b> Отрицательные значения размера не поддерживаются. При отрицательном размере большинство методов AABB работают некорректно. Используйте abs(), чтобы получить эквивалентный AABB с неотрицательным размером.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props AABB</code>",
                "\n<b>Методы объекта:</b> <code>/methods AABB</code>"
        ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/en/stable/classes/class_aabb.html"
        }
    },
    "4" : {
        "tags" : ["ARRAY", "МАССИВ", "МАССИВЫ", "НАБОР"],
        "body" : [
                "<b>Массив</b>\n",
                "\nМассив — это структура данных, которая может содержать последовательность элементов любого типа Variant. Доступ к элементам осуществляется по числовому индексу, начинающемуся с 0. Отрицательные индексы используются для отсчёта с конца \n-1 — это последний элемент, -2 — предпоследний и т.д.",
                "\nПример:",
                "<pre><code class='language-GDScript'>var array = ['First', 2, 3, 'Last'] # динамически\n типизированный словарь\nprint(array[0])  # Выведет 'First'\nprint(array[2])  # Выведет 3\nprint(array[-1]) # Выведет 'Last'\narray[1] = 'Second'\nprint(array[1])  # Выведет 'Second'\nprint(array[-3]) # Выведет 'Second'</code></pre>",
                "\n\n<blockquote expandable><b>Примечание:</b> Массивы всегда передаются по <b>ссылке</b>. Чтобы получить копию массива, которую можно изменять независимо от исходного массива, используйте функцию duplicate.</blockquote>",
                "\n\n<b>Упакованные (Packed):</b>",
                "\n\nУпакованные массивы быстрее поддаются итерации и изменению по сравнению с типизированными массивами того же типа, меньше занимают памяти, но менее гибкие, поскольку они не предоставляют столько удобных методов, как <code>map</code>",
                "\n<b>Методы объекта:</b> <code>/methods Array</code>"
        ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_array.html"
        }
    },
    "5" : {
        "tags" : ["BASIS", "БАСИС", "БАЗИС", "BAZIS"],
        "body" : [
                "<b>Basis</b>\n",
                "\nВстроенный тип Variant* — это матрица 3×3, используемая для представления 3D-вращения, масштабирования и сдвига. Она часто используется в Transform3D.",
                "\n\nБазис состоит из 3 векторов-осей, каждый из них представляет собой столбец матрицы: x, y и z. Длина каждой оси (Vector3.length) влияет на масштаб базиса, а направление всех осей влияет на поворот. Обычно эти оси перпендикулярны друг другу. Однако при повороте любой оси по отдельности базис становится сдвинутым. Если применить сдвинутый базис к 3D-модели, она будет выглядеть искажённой.",
                "\n\n<blockquote expandable><b>Примечание:</b> В Godot используется правосторонняя система координат, которая является общепринятым стандартом. Для встроенных типов, таких как Camera3D, направление -Z указывает вперёд (+X — вправо, +Y — вверх, +Z — назад). Для других объектов могут использоваться другие направления.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props Basis</code>",
                "\n<b>Методы объекта:</b> <code>/methods Basis</code>"
        ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_basis.html"
        }
    },
    "6" : {
        "tags" : ["BOOL", "BOOLEAN", "TRUE", "FALSE", "БУЛ", "БОЛЕАН", "БУЛЕАН", "ИСТИНА", "ЛОЖЬ"],
        "body" : [
                "<b>bool</b>\n",
                "\nBool — это встроенный тип Variant*, который может хранить только одно из двух значений: true или false. Вы можете представить его как переключатель, который можно включить или выключить, или как двоичную цифру, которая может быть равна 1 или 0.",
                "\n\nЛогические значения можно напрямую использовать в операторах if и других условных операторах.",
                "\n\n<blockquote expandable><b>Примечание:</b> В современных языках программирования логические операторы вычисляются по порядку. Все остальные условия пропускаются, если их результат не влияет на конечное значение. Эта концепция известна как вычисление по короткому замыканию и может быть полезна для того, чтобы избежать вычисления дорогостоящих условий в некоторых случаях, критичных для производительности.</blockquote>",
                "\nПримеры:",
                "<pre><code class='language-GDScript'>var can_shoot: bool = true\nif can_shoot:\n   launch_bullet()\n\nif bullets > 0 and not is_reloading():\n   launch_bullet()\n\nif bullets == 0 or is_reloading():\n   play_clack_sound()</code></pre>"
        ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_bool.html"
        }
    },
    "7" : {
        "tags" : ["CALLABLE", "КАЛАБЛЕ", "КАЛЛАБЛЕ", "ВЫЗЫВАЕМЫЙ", "ВЫЗЫВАЕМЫЕ", "CALABLE"],
        "body" : [
                "<b>Callable</b>\n",
                "\nCallable — это встроенный тип Variant*, представляющий собой функцию. Это может быть метод в экземпляре Object или пользовательская функция, используемая для различных целей. Как и все типы Variant*, она может храниться в переменных и передаваться другим функциям. Чаще всего она используется для обработки сигналов.",
                "\nПример:",
                "<pre><code class='language-GDScript'>func print_args(arg1, arg2, arg3 = ''):\n   prints(arg1, arg2, arg3)\n\nfunc test():\n   var callable = Callable(self, 'print_args')\n   callable.call('hello', 'world')  # Выведет 'hello world'\n   callable.call(Vector2.UP, 42, callable)  # Выведет '(0.0, -1.0) 42 Node(node.gd)::print_args'</code></pre>",
                "\n\n<blockquote expandable><b>Примечание:</b> В GDScript можно создавать лямбда-функции внутри метода. Лямбда-функции — это пользовательские вызываемые объекты, которые не связаны с экземпляром объекта. При необходимости лямбда-функциям можно присвоить имя. Имя будет отображаться в отладчике или при вызове <code>get_method</code>.</blockquote>",
                "\n\n<b>Пример лямбда-функции:</b>",
                "\n<pre><code class='language-GDScript'>func _init():\n   var my_lambda = func (message):\n      print(message)\n   # Вывести 'Hello everyone!'\n   my_lambda.call('Hello everyone!')\n   # Вывести 'Attack!', когда подаётся сигнал о нажатии кнопки\n   button_pressed.connect(func(): print('Attack!'))</code></pre>",
                "\n<b>Методы объекта:</b> <code>/methods Callable</code>"
        ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_callable.html"
        }
    },
    "8" : {
        "tags" : ["COLOR", "КОЛОР", "ЦВЕТА", "ЦВЕТ"],
        "body" : [
                "<b>Color</b>\n",
                "\nЦвет, представленный в формате RGBA с помощью красного (r), зелёного (g), синего (b) и альфа-компонентов (a). Каждый компонент представляет собой 32-битное значение с плавающей запятой, обычно в диапазоне от 0,0 до 1,0. Некоторые свойства (например, CanvasItem.modulate) могут поддерживать значения больше 1,0 для сверхярких цветов или цветов HDR (с высоким динамическим диапазоном).",
                "\n\nЦвета можно создавать разными способами: с помощью различных конструкторов Color, статических методов, таких как from_hsv, а также с помощью имени из набора стандартных цветов, основанного на названиях цветов X11 с добавлением TRANSPARENT. GDScript также предоставляет @GDScript.Color8, который использует целые числа от 0 до 255 и не поддерживает слишком яркие цвета.",
                "\n\n<blockquote expandable><b>Примечание:</b> В логическом контексте цвет будет считаться ложным, если он равен Color(0, 0, 0, 1) (непрозрачный чёрный). В противном случае цвет всегда будет считаться истинным.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props Color</code>",
                "\n<b>Методы объекта:</b> <code>/methods Color</code>"
        ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_color.html"
        }
    },
    "9" : {
        "tags" : ["DICTIONARY", "СЛОВАРЬ"],
        "body" : [
                "<b>Dictionary</b>\n",
                "\nСловари — это ассоциативные контейнеры, содержащие значения, на которые ссылаются уникальные ключи. Словари сохраняют порядок вставки при добавлении новых элементов. В других языках программирования эта структура данных часто называется хэш-картой или ассоциативным массивом.",
                "\nПример:",
                "<pre><code class='language-GDScript'>var my_dict = {} # Создает пустой словарь.\n\nvar dict_variable_key = 'Another key name'\nvar dict_variable_value = 'value2'\nvar another_dict = {\n   'Some key name': 'value1',\n   dict_variable_key: dict_variable_value,\n}</code></pre>",
                "\n\n<blockquote expandable><b>Примечание:</b> Словари всегда передаются по ссылке. Чтобы получить копию словаря, которую можно изменять независимо от исходного словаря, используйте функцию <code>duplicate</code>.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods Dictionary</code>"
        ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_dictionary.html"
        }
    },
    "10" : {
        "tags" : ["FLOAT", "ФЛОАТ", "ЧИСЛО С ПЛАВАЮЩЕЙ ТОЧКОЙ"],
        "body" : [
                "<b>float</b>\n",
                "\nВстроенный тип float — это 64-битное число с плавающей запятой двойной точности, эквивалентное типу <code>double</code> в C++. Этот тип имеет 14 надёжных десятичных знаков точности. Максимальное значение типа float составляет примерно <code>1,79769e308</code>, а минимальное — примерно <code>-1,79769e308</code>.",
                "\n\n<blockquote expandable><b>Примечание:</b> По умолчанию, многие методы в Godot используют 32 битную одинарную точность (6 знаков точночти), подобие float в C++. Можно скомпилировать движок с параметром <code>precision=double</code> для получения двойной точности во всех методах</blockquote>", 
                "\n\nМатематические вычисления с использованием типа данных float не гарантируют точность и часто приводят к небольшим ошибкам. Обычно для сравнения значений float на предмет равенства следует использовать методы @GlobalScope.is_equal_approx и @GlobalScope.is_zero_approx вместо <code>==</code>."
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_float.html"
        }
    },
    "11" : {
        "tags" : ["INT", "INTEGER", "ЧИСЛО", "ЦЕЛОЕ ЧИСЛО"],
        "body" : [
                "<b>int</b>\n",
                "\n64-битный целочисленный тип со знаком. Это означает, что он может принимать значения от <code>-2^63</code> до <code>2^63 - 1</code>, то есть от <code>-9223372036854775808</code> до <code>9223372036854775807</code>. Если значение выходит за эти пределы, оно округляется.",
                "\n\n<blockquote expandable><b>Примечание:</b> При необходимости int могут быть автоматически преобразованы в float, например при передаче их в качестве аргументов в функции. Float будет максимально приближено к исходному int.\n\nАналогичным образом float могут быть автоматически преобразованы в int. При этом float будет усечен, а всё, что находится после запятой, будет отброшено.</blockquote>", 
                "\n\nВ логическом контексте целое число будет равно <code>false</code>, если оно равно <code>0</code>, и равно <code>true</code> в противном случае.",
                "\n\nПримеры:",
                "<pre><code class='language-GDScript'>var x: int = 1 # x равно 1\nx = 4.2 # x равно 4, потому что 4,2 округляется до 4\nvar max_int = 9223372036854775807 # Максимальное значение, \n   которое может хранить тип данных int\nmax_int += 1 # max_int равно -9223372036854775808, \n   потому что оно округляется до нуля\nvar y = 0xF5 # разрешено двоичное представление\nvar z = 10_000_000 # разрешается делить числа для читаемости</code></pre>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_int.html"
        }
    },
    "12" : {
        "tags" : ["OBJECT", "ОБЪЕКТ"],
        "body" : [
                "<b>Object</b>\n",
                "\nРасширенный тип Variant*. Все классы в движке наследуются от Object. Каждый класс может определять новые свойства, методы или сигналы, доступные всем классам-наследникам. Например, экземпляр Sprite2D может вызывать Node.add_child, поскольку он наследуется от Node.",
                "\n\nВы можете создавать новые экземпляры, используя <code>Object.new()</code>",
                "\nЧтобы удалить экземпляр <code>Object</code>, вызовите функцию <code>free</code>. Это необходимо для большинства классов, наследующих Object, поскольку они не управляют памятью самостоятельно и в противном случае могут привести к утечке памяти, когда они больше не используются. Есть несколько классов, которые управляют памятью. Например, <code>RefCounted</code> (и, соответственно, <code>Resource</code>) удаляет себя, когда на него больше не ссылаются, а <code>Node</code> удаляет своих дочерних элементов при освобождении.",
                "\n\nК объектам можно прикрепить скрипт. После создания экземпляра скрипта он фактически становится расширением базового класса, позволяя ему определять и наследовать новые свойства, методы и сигналы.",
                "\n\nВы можете проверить, существует ли заданное свойство, метод или имя сигнала в объекте:",
                "<pre><code class='language-GDScript'>var node = Node.new()\nprint('name' in node)         # Выведет true\nprint('get_parent' in node)   # Выведет true\nprint('tree_entered' in node) # Выведет true\nprint('unknown' in node)      # Выведет false</code></pre>",
                "\n\n<blockquote expandable><b>Примечание:</b> В отличие от ссылок на <code>RefCounted</code>, ссылки на объект, хранящийся в переменной, могут стать недействительными без присвоения значения null. Чтобы проверить, был ли объект удалён, не сравнивайте его с null. Вместо этого используйте @GlobalScope.is_instance_valid. Также рекомендуется наследовать от RefCounted классы, хранящие данные, вместо <code>Object</code>.</blockquote>", 
                "\n\nВ логическом контексте объект будет считаться <code>false</code>, если он равен нулю или был освобождён. В противном случае объект всегда будет считаться <code>true</code>.",
                "\n<b>Методы объекта:</b> <code>/methods Object</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_object.html"
        }
    },
    "13" : {
        "tags" : ["PACKEDBYTEARRAY", "BYTEARRAY", "УПАКОВАННЫЙ МАССИВ БАЙТОВ"],
        "body" : [
                "<b>PackedByteArray</b>\n",
                "\nМассив, специально разработанный для хранения байтов. Плотно упаковывает данные, что позволяет экономить память при больших размерах массива. \n\n<code>PackedByteArray</code> также предоставляет методы для кодирования/декодирования различных типов в байты и обратно. Способ кодирования значений является деталью реализации, и на него не следует полагаться при взаимодействии с внешними приложениями.",
                "\n<blockquote expandable><b>Примечание:</b> Сжатые массивы всегда передаются по ссылке. Чтобы получить копию массива, которую можно изменять независимо от исходного массива, используйте метод <code>duplicate</code>. Это не относится к встроенным свойствам и методам. Чтобы обновить встроенное свойство, необходимо изменить возвращаемый массив, а затем снова присвоить его свойству.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods PackedByteArray</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_packedbytearray.html"
        }
    },
    "14" : {
        "tags" : ["PACKEDCOLORARRAY", "COLORARRAY", "УПАКОВАННЫЙ МАССИВ ЦВЕТОВ"],
        "body" : [
                "<b>PackedColorArray</b>\n",
                "\nМассив, специально разработанный для хранения данных о цвете. Плотно упаковывает данные, что позволяет экономить память при больших размерах массива.\n\nРазличия между упакованными массивами, типизированными массивами и нетипизированными массивами: упакованные массивы, как правило, быстрее перебирать и изменять по сравнению с типизированными массивами того же типа (например, PackedColorArray и Array[Color]). Кроме того, упакованные массивы потребляют меньше памяти. Недостатком упакованных массивов является их меньшая гибкость, поскольку они не предоставляют столько удобных методов, как, например, Array.map. Типизированные массивы, в свою очередь, быстрее перебирать и изменять, чем нетипизированные массивы.",
                "\n<blockquote expandable><b>Примечание:</b> Упакованные массивы всегда передаются по ссылке. Чтобы получить копию массива, которую можно изменять независимо от исходного массива, используйте метод <code>duplicate</code>. Это не относится к встроенным свойствам и методам. Чтобы обновить встроенное свойство, необходимо изменить возвращаемый массив, а затем снова присвоить его свойству.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods PackedColorArray</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_packedcolorarray.html"
        }
    },
    "15" : {
        "tags" : ["PACKEDFLOAT32ARRAY", "FLOAT32ARRAY", "УПАКОВАННЫЙ МАССИВ ЧИСЕЛ С ПЛАВАЮЩЕЙ ТОЧКОЙ 32"],
        "body" : [
                "<b>PackedFloat32Array</b>\n",
                "\nМассив, специально разработанный для хранения 32-битных float. Плотно упаковывает данные, что позволяет экономить память при больших размерах массива. \nСуществует также PackedFloat64Array",
                "\n<blockquote expandable><b>Примечание:</b> Упакованные массивы всегда передаются по ссылке. Чтобы получить копию массива, которую можно изменять независимо от исходного массива, используйте метод <code>duplicate</code>. Это не относится к встроенным свойствам и методам. Чтобы обновить встроенное свойство, необходимо изменить возвращаемый массив, а затем снова присвоить его свойству.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods PackedFloat32Array</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_packedfloat32array.html"
        }
    },
    "16" : {
        "tags" : ["PACKEDFLOAT64ARRAY", "FLOAT64ARRAY", "УПАКОВАННЫЙ МАССИВ ЧИСЕЛ С ПЛАВАЮЩЕЙ ТОЧКОЙ 64"],
        "body" : [
                "<b>PackedFloat64Array</b>\n",
                "\nМассив, специально разработанный для хранения 64-битных значений с плавающей запятой (double в C++). Плотно упаковывает данные, что позволяет экономить память при больших размерах массива.\nСуществует также PackedFloat32Array",
                "\n\nРазличия между упакованными массивами, типизированными массивами и нетипизированными массивами: упакованные массивы, как правило, быстрее перебирать и изменять по сравнению с типизированными массивами того же типа (например, PackedFloat64Array по сравнению с Array[float]). Кроме того, упакованные массивы потребляют меньше памяти. Недостатком упакованных массивов является их меньшая гибкость, поскольку они не предоставляют столько удобных методов, как, например, Array.map. Типизированные массивы, в свою очередь, быстрее перебирать и изменять, чем нетипизированные массивы.",
                "\n<blockquote expandable><b>Примечание:</b> Упакованные массивы всегда передаются по ссылке. Чтобы получить копию массива, которую можно изменять независимо от исходного массива, используйте метод <code>duplicate</code>. Это не относится к встроенным свойствам и методам. Чтобы обновить встроенное свойство, необходимо изменить возвращаемый массив, а затем снова присвоить его свойству.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods PackedFloat64Array</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_packedfloat32array.html"
        }
    },
    "17" : {
        "tags" : ["PACKEDINT32ARRAY", "INT32ARRAY", "УПАКОВАННЫЙ МАССИВ ЦЕЛЫХ ЧИСЕЛ 32"],
        "body" : [
                "<b>PackedInt32Array</b>\n",
                "\nМассив, специально разработанный для хранения 32-битных целочисленных значений. Плотно упаковывает данные, что позволяет экономить память при больших размерах массива.\nТакже существует PackedInt64Array",
                "\n<blockquote expandable><b>Примечание:</b> Этот тип хранит 32-битные целые числа со знаком, то есть может принимать значения в диапазоне <code>[-2^31, 2^31 - 1]</code>, то есть <code>[-2147483648, 2147483647]</code>. При превышении этих границ происходит обнуление. Для сравнения, тип int использует 64-битные целые числа со знаком, которые могут содержать гораздо более крупные значения.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods PackedInt32Array</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_packedint32array.html"
        }
    },
    "18" : {
        "tags" : ["PACKEDINT64ARRAY", "INT64ARRAY", "УПАКОВАННЫЙ МАССИВ ЦЕЛЫХ ЧИСЕЛ 64"],
        "body" : [
                "<b>PackedInt64Array</b>\n",
                "\nМассив, специально разработанный для хранения 64-битных целочисленных значений. Плотно упаковывает данные, что позволяет экономить память при больших размерах массива.\nСуществует также PackedInt32Array",
                "\n\nРазличия между упакованными массивами, типизированными массивами и нетипизированными массивами: упакованные массивы, как правило, быстрее перебирать и изменять по сравнению с типизированными массивами того же типа (например, PackedFloat64Array по сравнению с Array[float]). Кроме того, упакованные массивы потребляют меньше памяти. Недостатком упакованных массивов является их меньшая гибкость, поскольку они не предоставляют столько удобных методов, как, например, Array.map. Типизированные массивы, в свою очередь, быстрее перебирать и изменять, чем нетипизированные массивы.",
                "\n<blockquote expandable><b>Примечание:</b> Этот тип хранит 64-битные целые числа со знаком, что означает, что он может принимать значения в диапазоне <code>[-2^63, 2^63 - 1]</code>, то есть <code>[-9223372036854775808, 9223372036854775807]</code>. Превышение этих границ приведёт к переполнению.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods PackedInt64Array</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_packedint64array.html"
        }
    },
    "19" : {
        "tags" : ["PACKEDSTRINGARRAY", "STRINGARRAY", "УПАКОВАННЫЙ МАССИВ ТЕКСТА", "УПАКОВАННЫЙ МАССИВ СТРОК"],
        "body" : [
                "<b>PackedStringArray</b>\n",
                "\nМассив, специально разработанный для хранения строк. Плотно упаковывает данные, что позволяет экономить память при больших размерах массива. Если вы хотите объединить строки в массиве, используйте String.join",
                "\n\nРазличия между упакованными массивами, типизированными массивами и нетипизированными массивами: упакованные массивы, как правило, быстрее перебирать и изменять по сравнению с типизированными массивами того же типа (например, PackedStringArray  по сравнению с Array[String]). Кроме того, упакованные массивы потребляют меньше памяти. Недостатком упакованных массивов является их меньшая гибкость, поскольку они не предоставляют столько удобных методов, как, например, Array.map. Типизированные массивы, в свою очередь, быстрее перебирать и изменять, чем нетипизированные массивы.",
                "\n<blockquote expandable><b>Примечание:</b> Упакованные массивы всегда передаются по ссылке. Чтобы получить копию массива, которую можно изменять независимо от исходного массива, используйте метод <code>duplicate</code>. Это не относится к встроенным свойствам и методам. Чтобы обновить встроенное свойство, необходимо изменить возвращаемый массив, а затем снова присвоить его свойству.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods PackedStringArray</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_packedstringarray.html"
        }
    },
    "20" : {
        "tags" : ["PACKEDVECTOR2GARRAY", "VECTOR2ARRAY", "УПАКОВАННЫЙ МАССИВ ВЕКТОР 2", "УПАКОВАННЫЙ МАССИВ ВЕКТОРОВ 2"],
        "body" : [
                "<b>PackedVector2Array</b>\n",
                "\nМассив, специально разработанный для хранения <code>Vector2</code>. Плотно упаковывает данные, что позволяет экономить память при больших размерах массива.",
                "\n\nРазличия между упакованными массивами, типизированными массивами и нетипизированными массивами: упакованные массивы, как правило, быстрее перебирать и изменять по сравнению с типизированными массивами того же типа (например, PackedVector2Array по сравнению с Array[Vector2]). Кроме того, упакованные массивы потребляют меньше памяти. Недостатком упакованных массивов является их меньшая гибкость, поскольку они не предоставляют столько удобных методов, как, например, Array.map. Типизированные массивы, в свою очередь, быстрее перебирать и изменять, чем нетипизированные массивы.",
                "\n<blockquote expandable><b>Примечание:</b> Упакованные массивы всегда передаются по ссылке. Чтобы получить копию массива, которую можно изменять независимо от исходного массива, используйте метод <code>duplicate</code>. Это не относится к встроенным свойствам и методам. Чтобы обновить встроенное свойство, необходимо изменить возвращаемый массив, а затем снова присвоить его свойству.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods PackedVector2Array</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_packedvector2array.html"
        }
    },
    "21" : {
        "tags" : ["PACKEDVECTOR3GARRAY", "VECTOR3ARRAY", "УПАКОВАННЫЙ МАССИВ ВЕКТОР 3", "УПАКОВАННЫЙ МАССИВ ВЕКТОРОВ 3"],
        "body" : [
                "<b>PackedVector3Array</b>\n",
                "\nМассив, специально разработанный для хранения <code>Vector3</code>. Плотно упаковывает данные, что позволяет экономить память при больших размерах массива.",
                "\n\nРазличия между упакованными массивами, типизированными массивами и нетипизированными массивами: упакованные массивы, как правило, быстрее перебирать и изменять по сравнению с типизированными массивами того же типа (например, PackedVector3Array по сравнению с Array[Vector3]). Кроме того, упакованные массивы потребляют меньше памяти. Недостатком упакованных массивов является их меньшая гибкость, поскольку они не предоставляют столько удобных методов, как, например, Array.map. Типизированные массивы, в свою очередь, быстрее перебирать и изменять, чем нетипизированные массивы.",
                "\n<blockquote expandable><b>Примечание:</b> Упакованные массивы всегда передаются по ссылке. Чтобы получить копию массива, которую можно изменять независимо от исходного массива, используйте метод <code>duplicate</code>. Это не относится к встроенным свойствам и методам. Чтобы обновить встроенное свойство, необходимо изменить возвращаемый массив, а затем снова присвоить его свойству.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods PackedVector3Array</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_packedvector3array.html"
        }
    },
    "22" : {
        "tags" : ["PACKEDVECTOR4GARRAY", "VECTOR4ARRAY", "УПАКОВАННЫЙ МАССИВ ВЕКТОР 4", "УПАКОВАННЫЙ МАССИВ ВЕКТОРОВ 4"],
        "body" : [
                "<b>PackedVector4Array</b>\n",
                "\nМассив, специально разработанный для хранения <code>Vector4</code>. Плотно упаковывает данные, что позволяет экономить память при больших размерах массива.",
                "\n\nРазличия между упакованными массивами, типизированными массивами и нетипизированными массивами: упакованные массивы, как правило, быстрее перебирать и изменять по сравнению с типизированными массивами того же типа (например, PackedVector4Array по сравнению с Array[Vector4]). Кроме того, упакованные массивы потребляют меньше памяти. Недостатком упакованных массивов является их меньшая гибкость, поскольку они не предоставляют столько удобных методов, как, например, Array.map. Типизированные массивы, в свою очередь, быстрее перебирать и изменять, чем нетипизированные массивы.",
                "\n<blockquote expandable><b>Примечание:</b> Упакованные массивы всегда передаются по ссылке. Чтобы получить копию массива, которую можно изменять независимо от исходного массива, используйте метод <code>duplicate</code>. Это не относится к встроенным свойствам и методам. Чтобы обновить встроенное свойство, необходимо изменить возвращаемый массив, а затем снова присвоить его свойству.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods PackedVector4Array</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_packedvector4array.html"
        }
    },
    "23" : {
        "tags" : ["PLANE", "ПЛОСКОСТЬ"],
        "body" : [
                "<b>Plane</b>\n",
                "\nПлоскость в нормальной форме Гессе (Hessian).",
                "\n\nПредставляет собой нормализованное уравнение плоскости. normal — это нормаль к плоскости (a, b, c нормализованы), а d — расстояние от начала координат до плоскости (в направлении «нормали»). Over или Above плоскости считается та сторона плоскости, в направлении которой направлена нормаль.",
                "\n<b>Свойства объекта:</b> <code>/props Plane</code>",
                "\n<b>Методы объекта:</b> <code>/methods Plane</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_plane.html"
        }
    },
    "24" : {
        "tags" : ["PROJECTION", "ПРОЕКЦИЯ"],
        "body" : [
                "<b>Projection</b>\n",
                "\nМатрица 4×4, используемая для проективных преобразований в 3D. Она может представлять такие преобразования, как перемещение, поворот, масштабирование, сдвиг и перспективное деление. Она состоит из четырёх столбцов <code>Vector4</code>.",
                "\n\nДля чисто линейных преобразований (сдвиг, поворот и масштабирование) рекомендуется использовать <code>Transform3D</code>, так как он более производительный и требует меньше памяти.\nИспользуется внутри как матрица проекции <code>Camera3D</code>.",
                "\n<b>Свойства объекта:</b> <code>/props Projection</code>",
                "\n<b>Методы объекта:</b> <code>/methods Projection</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_projection.html"
        }
    },
    "25" : {
        "tags" : ["QUATERNION", "КВАНТЕРИОН"],
        "body" : [
                "<b>Quaternion</b>\n",
                "\nВстроенный тип данных Квантерион — это четырёхмерная структура данных, представляющая вращение в виде кватерниона Гамильтона (Hamilton). По сравнению с типом Basis, который может хранить как вращение, так и масштаб, кватернионы могут хранить только вращение.",
                "\n\nКвантерион состоит из 4 float: w, x, y и z. Эти компоненты занимают очень мало места в памяти, поэтому некоторые операции выполняются быстрее и с меньшей вероятностью приведут к ошибкам. Такие методы, как <code>get_angle</code>, <code>get_axis</code> и <code>slerp</code>, работают быстрее, чем их аналоги в Basis.",
                "\n<blockquote expandable><b>Примечание:</b> Перед использованием кватернионов для вращения их необходимо нормализовать.</blockquote>",
                "\n\n<blockquote expandable><b>Примечание:</b> Как и в случае с Vector2 и Vector3, компоненты кватерниона по умолчанию используют 32-битную точность, в отличие от <code>float</code>, которая всегда 64-битная. Если требуется двойная точность, скомпилируйте движок с опцией <code>precision=double</code>.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props Quaternion</code>",
                "\n<b>Методы объекта:</b> <code>/methods Quaternion</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_quaternion.html"
        }
    },
    "26" : {
        "tags" : ["RECT2I", "ОГРАНИЧИВАЮЩАЯ РАМКА 2Д"],
        "body" : [
                "<b>Rect2i</b>\n",
                "\nВстроенный тип данных <code>Rect2i</code> представляет собой прямоугольник, выровненный по осям в двумерном пространстве, с использованием целочисленных координат. Он определяется своим положением и размером, которые задаются вектором <code>Vector2i</code>. Поскольку он не вращается, его часто используют для быстрого тестирования на пересечение.",
                "\n<blockquote expandable><b>Примечание:</b> Отрицательные значения размера не поддерживаются. При отрицательном размере большинство методов <code>Rect2i</code> работают некорректно. Используйте <code>abs()</code>, чтобы получить эквивалентный <code>Rect2i</code> с неотрицательным размером.</blockquote>",
                "\n\nВ логическом контексте <code>Rect2i</code> оценивается как <code>false</code>, если и положение, и размер равны нулю (равны <code>Vector2i.ZERO</code>). В противном случае он всегда оценивается как <code>true</code>.",
                "\n<b>Свойства объекта:</b> <code>/props Rect2i</code>",
                "\n<b>Методы объекта:</b> <code>/methods Rect2i</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_rect2i.html"
        }
    },
    "27" : {
        "tags" : ["RECT2", "ОГРАНИЧИВАЮЩАЯ РАМКА 2Д"],
        "body" : [
                "<b>Rect2</b>\n",
                "\nВстроенный тип данных <code>Rect2</code> представляет собой прямоугольник, выровненный по осям в двумерном пространстве, с использованием целочисленных координат. Он определяется своим положением и размером, которые задаются вектором <code>Vector2</code>. Поскольку он не вращается, его часто используют для быстрого тестирования на пересечение.",
                "\n<blockquote expandable><b>Примечание:</b> Отрицательные значения размера не поддерживаются. При отрицательном размере большинство методов <code>Rect2</code> работают некорректно. Используйте <code>abs()</code>, чтобы получить эквивалентный <code>Rect2</code> с неотрицательным размером.</blockquote>",
                "\n\nВ логическом контексте <code>Rect2</code> оценивается как <code>false</code>, если и положение, и размер равны нулю (равны <code>Vector2.ZERO</code>). В противном случае он всегда оценивается как <code>true</code>.",
                "\n<b>Свойства объекта:</b> <code>/props Rect2</code>",
                "\n<b>Методы объекта:</b> <code>/methods Rect2</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_rect2.html"
        }
    },
    "28" : {
        "tags" : ["RID", "РИД"],
        "body" : [
                "<b>RID</b>\n",
                "\nТип RID Variant* используется для доступа к низкоуровневому ресурсу по его уникальному идентификатору. Идентификаторы RID являются непрозрачными, то есть сами по себе не предоставляют доступ к ресурсу. Они используются низкоуровневыми серверными классами, такими как DisplayServer, RenderingServer, TextServer и т.д.\n\nРесурс низкого уровня может соответствовать ресурсу высокого уровня, такому как текстура или сетка.",
                "\n\n<blockquote expandable><b>Примечание:</b> Идентификаторы полезны только во время текущего сеанса. Они не будут соответствовать аналогичному ресурсу, если будут отправлены по сети или загружены из файла позднее.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods RID</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_rid.html"
        }
    },
    "29" : {
        "tags" : ["SIGNAL", "СИГНАЛ", "SIGNALS", "СИГНАЛЫ"],
        "body" : [
                "<b>Signal</b>\n",
                "\nСигнал — это встроенный тип Variant*, представляющий собой сигнал экземпляра объекта. Как и все типы Variant*, он может храниться в переменных и передаваться функциям. Сигналы позволяют всем подключённым Callables (и, соответственно, их объектам) прослушивать и реагировать на события, не ссылаясь напрямую друг на друга. Это делает код гибким и упрощает управление.",
                "\n\n<blockquote expandable><b>Примечание:</b> Cигналы можно объявлять с помощью ключевого слова <code>signal</code>.\nВы можете проверить, есть ли у объекта заданное имя сигнала, с помощью <code>Object.has_signal</code>.</blockquote>",
                "\n<pre><code class='language-GDScript'>signal attacked\n\n#Могут быть указаны дополнительные аргументы.\n#Эти аргументы должны быть указаны\n   при отправке сигнала\nsignal item_dropped(item_name, amount)</code></pre>",
                "\n<b>Методы объекта:</b> <code>/methods Signal</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_signal.html"
        }
    },
    "30" : {
        "tags" : ["STRING", "СТРИНГ", "TEXT", "ТЕКСТ", "БУКВЫ", "LETTER", "CHARACTER", "SING", "ЗНАК"],
        "body" : [
                "<b>String</b>\n",
                "\nВстроенный строковый тип Variant*. Строки могут содержать любое количество символов Юникода и предоставляют методы, полезные для работы со строками и их создания. Строки подсчитывают количество ссылок и используют подход «копирование при записи» (при каждом изменении строки создаётся новая строка), поэтому их передача не требует больших ресурсов.",
                "\n\n<blockquote expandable><b>Примечание:</b> Некоторые строковые методы имеют соответствующие вариации. Вариации с суффиксом <code>n</code> (countn, findn, replacen и т. д.) нечувствительны к регистру (нет различий между прописными и строчными буквами). Вариации методов с префиксом <code>r</code> (rfind, rsplit и т. д.) являются обратными и начинаются с конца строки, а не с начала.</blockquote>",
                "\n\n<blockquote expandable><b>Примечание:</b> Чтобы преобразовать любой вариант в строку или из строки, используйте <code>@GlobalScope.str</code>, <code>@GlobalScope.str_to_var</code> и <code>@GlobalScope.var_to_str</code>.</blockquote>",
                "\nВ логическом контексте строка будет считаться <code>false</code>, если она пуста (''). В противном случае строка всегда будет считаться <code>true</code>.",
                "\n<b>Методы объекта:</b> <code>/methods String</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_string.html"
        }
    },
    "31" : {
        "tags" : ["STRINGNAME", "СТРИНГНЕЙМ", "STRING NAME", "СТРИНГ НЕЙМ", "СТРИНГНАМЕ", "СТРИНГ НАМЕ", "СТРИНГНАЙМ", "СТРИНГ НАЙМ"],
        "body" : [
                "<b>StringName</b>\n",
                "\nStringNames — это неизменяемые строки, предназначенные для универсального представления уникальных имён (также называемых Строками-интернинг). Две строки StringNames с одинаковым значением являются одним и тем же объектом. Их сравнение происходит чрезвычайно быстро по сравнению с обычными строками.",
                "\n\n<blockquote expandable><b>Примечание:</b> Обычно вы передаёте строку методам, ожидающим <code>StringName</code>, и она автоматически преобразуется (часто во время компиляции), но в редких случаях вы можете заранее создать <code>StringName</code> с помощью конструктора <code>StringName</code> или, в GDScript, с помощью литерала <code>&'example'</code>. Создание <code>StringName</code> вручную позволяет контролировать, когда происходит преобразование из строки, или использовать литерал и полностью предотвратить преобразование.</blockquote>",
                "\n\n<blockquote expandable><b>Примечание:</b> Все методы <code>String</code> доступны и в этом классе. Они преобразуют <code>StringName</code> в строку и возвращают строку. Это крайне неэффективно и должно использоваться только в том случае, если требуется строка.</blockquote>",
                "\nВ логическом контексте <code>StringName </code> будет считаться <code>false</code>, если она пуста (StringName('')). В противном случае строка всегда будет считаться <code>true</code>.",
                "\n<b>Методы объекта:</b> <code>/methods StringName</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_stringname.html"
        }
    },
    "32" : {
        "tags" : ["TRANSFORM2D", "ТРАНСФОРМ2Д", "ТРАНСФОРМАЦИЯ2Д"],
        "body" : [
                "<b>Transform2D</b>\n",
                "\nВстроенный тип Transform2D — это матрица 2×3, представляющая преобразование в двумерном пространстве. Она содержит три значения <code>Vector2(x, y)</code> и начало координат. В совокупности они могут представлять перемещение, вращение, масштабирование и наклон.",
                "\n\n<blockquote expandable><b>Примечание:</b> Оси <code>x</code> и <code>y</code> образуют матрицу 2×2, известную как основа преобразования. Длина каждой оси <code>(Vector2.length)</code> влияет на масштаб преобразования, а направление всех осей влияет на поворот. Обычно обе оси перпендикулярны друг другу. Однако при повороте одной оси преобразование становится искажённым. Если применить искажённое преобразование к 2D-спрайту, он будет выглядеть искажённым.</blockquote>",
                "\n\n<blockquote expandable><b>Примечание:</b> В отличие от <code>Transform3D</code>, в 2D нет эквивалента типа <code>Basis</code>. Все упоминания основы относятся к компонентам <code>x</code> и <code>y</code> в <code>Transform2D</code>.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props Transform2D</code>",
                "\n<b>Методы объекта:</b> <code>/methods Transform2D</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_transform2d.html"
        }
    },
    "33" : {
        "tags" : ["TRANSFORM3D", "ТРАНСФОРМ3Д", "ТРАНСФОРМАЦИЯ3Д"],
        "body" : [
                "<b>Transform3D</b>\n",
                "\nВстроенный тип Transform3D — это матрица 3×4, представляющая преобразование в 3D пространстве. Она содержит в себе <code>Basis</code>, что само по себе может означать вращение, масштабирование и сдвиг. и начало координат. Кроме того, в сочетании с собственным началом координат преобразование может также представлять собой перевод.",
                "\n\n<blockquote expandable><b>Примечание:</b> В Godot используется правосторонняя система координат, которая является общепринятым стандартом. Для встроенных типов, таких как <code>Camera3D</code>, направление <code>-Z</code> указывает вперёд (+X — вправо, +Y — вверх, +Z — назад). Для других объектов могут использоваться другие направления.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props Transform3D</code>",
                "\n<b>Методы объекта:</b> <code>/methods Transform3D</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_transform3d.html"
        }
    },
    "34" : {
        "tags" : ["VECTOR2","VECTOR2D", "ВЕКТОР2", "ВЕКТОР2Д"],
        "body" : [
                "<b>Vector2</b>\n",
                "\nСтруктура из двух элементов, которую можно использовать для представления 2D координат или любой другой пары числовых значений.",
                "\n\n<blockquote expandable><b>Примечание:</b> Он использует координаты с плавающей запятой. По умолчанию эти значения с плавающей запятой имеют 32-битную точность, в отличие от <code>float</code>, которая всегда 64-битная. Если требуется двойная точность, скомпилируйте движок с опцией <code>precision=double</code>.</blockquote>",
                "\nВ логическом контексте Vector2 будет иметь значение <code>false</code>, если он равен <code>Vector2(0, 0)</code>. В противном случае <code>Vector2</code> всегда будет иметь значение <code>true</code>.",
                "\n<b>Свойства объекта:</b> <code>/props Vector2</code>",
                "\n<b>Методы объекта:</b> <code>/methods Vector2</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_vector2.html"
        }
    },
    "35" : {
        "tags" : ["VECTOR2I","VECTOR2DI", "ВЕКТОР2", "ВЕКТОР2Д"],
        "body" : [
                "<b>Vector2i</b>\n",
                "\nСтруктура из двух элементов, которую можно использовать для представления 2D координат или любой другой пары числовых значений.",
                "\n\n<blockquote expandable><b>Примечание:</b> Он использует целочисленные координаты. По умолчанию эти значения имеют 32-битную точность, которую нельзя изменить перекомпиляцией движка. Если вам нужны 64-битные значения, используйте <code>int</code> или <code>PackedInt64Array</code>.</blockquote>",
                "\nВ логическом контексте Vector2 будет иметь значение <code>false</code>, если он равен <code>Vector2i(0, 0)</code>. В противном случае <code>Vector2i</code> всегда будет иметь значение <code>true</code>.",
                "\n<b>Свойства объекта:</b> <code>/props Vector2i</code>",
                "\n<b>Методы объекта:</b> <code>/methods Vector2i</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_vector2i.html"
        }
    },
    "36" : {
        "tags" : ["VECTOR3","VECTOR3D", "ВЕКТОР3", "ВЕКТОР3Д"],
        "body" : [
                "<b>Vector3</b>\n",
                "\nСтруктура из трёх элементов, которую можно использовать для представления 3D координат или любого другого набора числовых значений.",
                "\n\n<blockquote expandable><b>Примечание:</b> Он использует координаты с плавающей запятой. По умолчанию эти значения с плавающей запятой имеют 32-битную точность, в отличие от <code>float</code>, которая всегда 64-битная. Если требуется двойная точность, скомпилируйте движок с опцией <code>precision=double</code>.</blockquote>",
                "\nВ логическом контексте Vector3 будет иметь значение <code>false</code>, если он равен <code>Vector3(0, 0, 0)</code>. В противном случае <code>Vector3</code> всегда будет иметь значение <code>true</code>.",
                "\n<b>Свойства объекта:</b> <code>/props Vector3</code>",
                "\n<b>Методы объекта:</b> <code>/methods Vector3</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_vector3.html"
        }
    },
    "37" : {
        "tags" : ["VECTOR3I","VECTOR2DI", "ВЕКТОР3", "ВЕКТОР3Д"],
        "body" : [
                "<b>Vector3i</b>\n",
                "\nСтруктура из двух элементов, которую можно использовать для представления 3D координат или любой другой пары числовых значений.",
                "\n\n<blockquote expandable><b>Примечание:</b> Он использует целочисленные координаты. По умолчанию эти значения имеют 32-битную точность, которую нельзя изменить перекомпиляцией движка. Если вам нужны 64-битные значения, используйте <code>int</code> или <code>PackedInt64Array</code>.</blockquote>",
                "\nВ логическом контексте Vector3 будет иметь значение <code>false</code>, если он равен <code>Vector3i(0, 0)</code>. В противном случае <code>Vector3i</code> всегда будет иметь значение <code>true</code>.",
                "\n<b>Свойства объекта:</b> <code>/props Vector3i</code>",
                "\n<b>Методы объекта:</b> <code>/methods Vector3i</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_vector3i.html"
        }
    },
    "38" : {
        "tags" : ["VECTOR4","VECTOR4D", "ВЕКТОР4", "ВЕКТОР4Д"],
        "body" : [
                "<b>Vector4</b>\n",
                "\nСтруктура из четырех элементов, которую можно использовать для представления 4D координат или любого другого набора числовых значений.",
                "\n\n<blockquote expandable><b>Примечание:</b> Он использует координаты с плавающей запятой. По умолчанию эти значения с плавающей запятой имеют 32-битную точность, в отличие от <code>float</code>, которая всегда 64-битная. Если требуется двойная точность, скомпилируйте движок с опцией <code>precision=double</code>.</blockquote>",
                "\nВ логическом контексте Vector4 будет иметь значение <code>false</code>, если он равен <code>Vector4(0, 0, 0, 0)</code>. В противном случае <code>Vector4</code> всегда будет иметь значение <code>true</code>.",
                "\n<b>Свойства объекта:</b> <code>/props Vector4</code>",
                "\n<b>Методы объекта:</b> <code>/methods Vector4</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_vector4.html"
        }
    },
    "39" : {
        "tags" : ["VECTOR4I","VECTOR4DI", "ВЕКТОР4", "ВЕКТОР4Д"],
        "body" : [
                "<b>Vector4i</b>\n",
                "\nСтруктура из двух элементов, которую можно использовать для представления 4D координат или любой другой пары числовых значений.",
                "\n\n<blockquote expandable><b>Примечание:</b> Он использует целочисленные координаты. По умолчанию эти значения имеют 32-битную точность, которую нельзя изменить перекомпиляцией движка. Если вам нужны 64-битные значения, используйте <code>int</code> или <code>PackedInt64Array</code>.</blockquote>",
                "\nВ логическом контексте Vector4 будет иметь значение <code>false</code>, если он равен <code>Vector4i(0, 0)</code>. В противном случае <code>Vector4i</code> всегда будет иметь значение <code>true</code>.",
                "\n<b>Свойства объекта:</b> <code>/props Vector4i</code>",
                "\n<b>Методы объекта:</b> <code>/methods Vector4i</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_vector4i.html"
        }
    },
    "40" : {
        "tags" : ["GDSCRIPT", "ГДСКРИПТ"],
        "body" : [
                "🟠Globals: <b>@GDScript</b>\n",
                "\n<blockquote expandable>Встроенные константы, функции и аннотации <code>GDScript</code>. Список служебных функций и аннотаций, доступных из любого скрипта, написанного на GDScript. Список глобальных функций и констант, доступных из любого скрипта, см. в разделе <code>@GlobalScope</code></blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods GDScript</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_%40gdscript.html"
        }
    },
    "41" : {
        "tags" : ["GLOBALSCOPE", "ГЛОБАЛЬНЫЙ МАСШТАБ"],
        "body" : [
                "🟠Globals: <b>@GlobalScope</b>\n",
                "\n<blockquote expandable>Константы и функции глобальной области видимости. Список перечислимых констант и встроенных функций в глобальной области видимости. Это всё, что находится в глобальной области видимости: константы, связанные с кодами ошибок, кодами клавиш, подсказками свойств и т. д. Здесь также описаны синглтоны, поскольку доступ к ним возможен из любого места. Записи, доступ к которым возможен только из скриптов, написанных на <code>GDScript</code>, см. в <code>@GDScript</code>.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props GlobalScope</code>",
                "\n<b>Методы объекта:</b> <code>/methods GlobalScope</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_%40globalscope.html"
        }
    },
    "42" : {
        "tags" : ["NODE", "НОДА", "NODE2D", "NODE3D", "НОДА 3Д", "НОДА 2Д"],
        "body" : [
                "⚪️Нода: <b>Node</b>\n",
                "\nNode (узлы) — это строительные блоки Godot. Могут быть дочерними по отношению к другому узлу, создавая древовидной структуры (сцен). Узел может содержать любое количество дочерних узлов, при этом все одноуровневые узлы (прямые дочерние узлы) должны иметь уникальные имена.\nСцены можно сохранять на диск, а затем создавать их экземпляры в других сценах.",
                "\n\n<blockquote expandable><b>Примечание:</b> Когда узел добавляется в дерево сцены, он получает уведомление <code>NOTIFICATION_ENTER_TREE</code>, и срабатывает его обратный вызов <code>_enter_tree</code>. Этот вызов срабатывается у родителя раньше, чем у дочернего\nПосле добавления всех узлов в дерево сцены они получают уведомление <code>NOTIFICATION_READY</code></blockquote>",
                "\n\nУзлы можно добавлять в любое количество групп, чтобы ими было легко управлять. Например, в зависимости от вашей игры вы можете создать такие группы, как <code>враги</code> или <code>предметы для сбора</code>",
                "\n<b>Свойства объекта:</b> <code>/props Node</code>",
                "\n<b>Методы объекта:</b> <code>/methods Node</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_node.html"
        }
    },
    "43" : {
        "tags" : ["ACCEPTDIALOG", "ДИАЛОГОВОЕ ОКНО"],
        "body" : [
                "⚪️Нода: <b>AcceptDialog</b>\n",
                "\nБазовый диалог для уведомления пользователей. По умолчанию <code>AcceptDialog</code> позволяет либо принять запрос, либо закрыть его с тем же результатом. Однако сигналы подтверждения и отмены позволяют выполнять два разных действия, а метод <code>add_button</code> позволяет добавлять пользовательские кнопки и действия.",
                "\n<b>Свойства объекта:</b> <code>/props AcceptDialog</code>",
                "\n<b>Методы объекта:</b> <code>/methods AcceptDialog</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_acceptdialog.html"
        }
    },
    "44" : {
        "tags" : ["ANIMATABLEBODY", "АНИМИРУЕМОЕ ТЕЛО", "ANIMATABLEBODY2D", "ANIMATABLEBODY3D", "ANIMATIONBODY", "ANIMATIONBODY2D", "ANIMATIONBODY3D"],
        "body" : [
                "Ноды: <b>AnimatableBody2D и AnimatableBody3D</b>\n",
                "\n🔵AnimatableBody2D:",
                "\n<blockquote expandable>Анимируемое 2D-физическое тело. Его нельзя переместить с помощью внешних сил или контактов, но можно переместить вручную с помощью других средств, таких как код, <code>AnimationMixers</code> (с параметром <code>AnimationMixer.callback_mode_process</code>, установленным на <code>AnimationMixer.ANIMATION_CALLBACK_MODE_PROCESS_PHYSICS</code>) и <code>RemoteTransform2D</code>.\n\nПри перемещении <code>AnimatableBody2D</code> вычисляются его линейная и угловая скорость, которые используются для воздействия на другие физические тела на его пути. Это позволяет использовать его для перемещения платформ, дверей и других движущихся объектов.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props AnimatableBody2D</code>",
                "\n\n🔴AnimatableBody3D:",
                "\n<blockquote expandable>Анимируемое 3D-физическое тело. Его нельзя переместить с помощью внешних сил или контактов, но можно переместить вручную с помощью других средств, таких как код, <code>AnimationMixers</code> (с параметром <code>AnimationMixer.callback_mode_process</code>, установленным на <code>AnimationMixer.ANIMATION_CALLBACK_MODE_PROCESS_PHYSICS</code>) и <code>RemoteTransform3D</code>.\n\nПри перемещении <code>AnimatableBody3D</code> вычисляются его линейная и угловая скорость, которые используются для воздействия на другие физические тела на его пути. Это позволяет использовать его для перемещения платформ, дверей и других движущихся объектов.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props AnimatableBody3D</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_animatablebody2d.html"
        }
    },
    "45" : {
        "tags" : ["ANIMATEDSPRITE", "АНИМИРОВАННЫЙ СПРАЙТ", "ANIMATIONSPRITE", "ANIMATEDSPRITE2D", "ANIMATEDSPRITE3D", "АНИМИРОВАННЫЙ СПРАЙТ 2Д", "АНИМИРОВАННЫЙ СПРАЙТ 3Д", "ANIMATIONSPRITE", "ANIMATIONSPRITE2D", "ANIMATIONSPRITE3D" ],
        "body" : [
                "Ноды: <b>AnimatedSprite2D и AnimatedSprite2D</b>\n",
                "\n🔵AnimatedSprite2D:",
                "\n<blockquote expandable><code>AnimatedSprite2D</code> похож на узел <code>Sprite2D</code>, за исключением того, что он содержит несколько текстур в качестве кадров анимации. Анимация создаётся с помощью ресурса <code>SpriteFrames</code>, который позволяет импортировать файлы изображений (или папку с такими файлами) для создания кадров анимации для спрайта. Ресурс <code>SpriteFrames</code> можно настроить в редакторе на нижней панели <code>SpriteFrames</code>.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props AnimatedSprite2D</code>",
                "\n<b>Методы объекта:</b> <code>/methods AnimatedSprite2D</code>",
                "\n\n🔴AnimatedSprite3D:",
                "\n<blockquote expandable><code>nAnimatedSprite3D</code> похож на узел <code>Sprite3D</code>, за исключением того, что он содержит несколько текстур в качестве кадров анимации. Анимация создаётся с помощью ресурса <code>SpriteFrames</code>, который позволяет импортировать файлы изображений (или папку с такими файлами) для создания кадров анимации для спрайта. Ресурс <code>SpriteFrames</code> можно настроить в редакторе на нижней панели <code>SpriteFrames</code>.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props AnimatedSprite3D</code>",
                "\n<b>Методы объекта:</b> <code>/methods AnimatedSprite3D</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_animatedsprite2d.html"
        }
    },
    "46" : {
        "tags" : ["ANIMATION", "АНИМАЦИИ"],
        "body" : [
                "Ноды: <b>AnimationMixer, AnimationPlayer и AnimationTree</b>\n",
                "\n🟣AnimationMixer:",
                "\n<blockquote expandable>Базовый класс для <code>AnimationPlayer</code> и <code>AnimationTree</code>, предназначенный для управления списками анимаций. Он также обладает общими свойствами и методами для воспроизведения и наложения. После создания экземпляра данных воспроизведения в расширенном классе наложение обрабатывается с помощью <code>AnimationMixer</code>.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props AnimationMixer</code>",
                "\n<b>Методы объекта:</b> <code>/methods AnimationMixer</code>",
                "\n\n🟣AnimationPlayer:",
                "\n<blockquote expandable>Проигрыватель анимации используется для воспроизведения анимации общего назначения. Он содержит словарь ресурсов <code>AnimationLibrary</code> и настраиваемое время перехода между анимациями.\n\n<code>AnimationPlayer</code> лучше подходит для более сложных анимаций, чем <code>Tween</code>, например для анимаций с нетривиальным таймингом. Его также можно использовать вместо <code>Tween</code>, если редактор анимационных дорожек удобнее, чем написание кода.\nОбновление целевых свойств анимации происходит в процессе работы.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props AnimationPlayer</code>",
                "\n<b>Методы объекта:</b> <code>/methods AnimationPlayer</code>",
                "\n\n🟣AnimationTree:",
                "\n<blockquote expandable>Узел, используемый для расширенных анимационных переходов в <code>AnimationPlayer</code>.\n\n<b>Примечание:</b> При подключении к <code>AnimationPlayer</code> некоторые свойства и методы соответствующего <code>AnimationPlayer</code> не будут работать должным образом. Воспроизведение и переходы должны обрабатываться только с помощью <code>AnimationTree</code> и составляющих его <code>AnimationNode</code>(ов). Узел <code>AnimationPlayer</code> должен использоваться исключительно для добавления, удаления и редактирования анимаций.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props AnimationTree</code>",
                "\n<b>Методы объекта:</b> <code>/methods AnimationTree</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_animationmixer.html"
        }
    },
    "47" : {
        "tags" : ["AREA", "ОБЛАСТЬ"],
        "body" : [
                "Ноды: <b>Area2D и Area3D</b>\n",
                "\n🔵Area2D:",
                "\n<blockquote expandable><code>Area2D</code> — это область 2D пространства, определяемая одним или несколькими дочерними узлами <code>CollisionShape2D</code> или <code>CollisionPolygon2D</code>. Она определяет, когда другие объекты <code>CollisionObject2D</code> входят в неё или выходят из неё, а также отслеживает, какие объекты ещё не вышли из неё (то есть какие из них перекрывают её). Этот узел также может локально изменять или переопределять физические параметры (гравитацию, демпфирование) и направлять звук на пользовательские аудиошины.\n\n<b>Примечание:</b> Зоны и тела, созданные с помощью <code>PhysicsServer2D</code>, могут не взаимодействовать должным образом с <code>Area2D</code>, а также могут неправильно генерировать сигналы или отслеживать объекты.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props Area2D</code>",
                "\n<b>Методы объекта:</b> <code>/methods Area2D</code>",
                "\n\n🔴Area3D:",
                "\n<blockquote expandable><code>Area3D</code> — это область 3D пространства, определяемая одним или несколькими дочерними узлами <code>CollisionShape3D</code> или <code>CollisionPolygon3D</code>. Она определяет, когда другие объекты <code>CollisionObject3D</code> входят в неё или выходят из неё, а также отслеживает, какие объекты ещё не вышли из неё (то есть какие из них перекрывают её). Этот узел также может локально изменять или переопределять физические параметры (гравитацию, демпфирование) и направлять звук на пользовательские аудиошины.\n\n<b>Примечание:</b> Зоны и тела, созданные с помощью <code>PhysicsServer3D</code>, могут не взаимодействовать должным образом с <code>Area3D</code>, а также могут неправильно генерировать сигналы или отслеживать объекты.</blockquote>",
                "\n<blockquote expandable><b>Предупреждение:</b> использование <code>ConcavePolygonShape3D</code> внутри <code>CollisionShape3D</code>, дочернего элемента этого узла (созданного, например, с помощью опции <code>Create Trimesh Collision Sibling</code> в меню <code>Mesh</code>, которое появляется при выборе узла <code>MeshInstance3D</code>), может привести к неожиданным результатам, поскольку эта форма столкновения является полой. Если это нежелательно, ее нужно разделить на несколько <code>ConvexPolygonShape3D</code> или примитивных форм, таких как <code>BoxShape3D</code>, а в некоторых случаях ее можно заменить на <code>CollisionPolygon3D</code>.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props Area3D</code>",
                "\n<b>Методы объекта:</b> <code>/methods Area3D</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_area2d.html"
        }
    },
    "48" : {
        "tags" : ["ASPECTRATIOCONTAINER", "СООТНОШЕНИЕ СТОРОН"],
        "body" : [
                "🟢Нода: <b>AspectRatioContainer</b>\n",
                "\n<blockquote expandable>Тип контейнера, который упорядочивает дочерние элементы управления таким образом, чтобы они автоматически сохраняли свои пропорции при изменении размера контейнера. Полезно, когда контейнер имеет динамический размер, а дочерние узлы должны соответствующим образом изменять свой размер без потери пропорций.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props Area2D</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_aspectratiocontainer.html"
        }
    },
    "49" : {
        "tags" : ["AUDIO", "АУДИО"],
        "body" : [
                "Ноды: <b>AudioListener2D, AudioListener3D, AudioStreamPlayer, AudioStreamPlayer2D, AudioStreamPlayer3D</b>\n",
                "\n🔵AudioListener2D:",
                "\n<blockquote expandable>После добавления в дерево сцены и активации с помощью <code>make_current</code> этот узел будет определять местоположение, из которого слышны звуки. Только один <code>AudioListener2D</code> может быть активным. Использование <code>make_current</code> приведет к отключению предыдущего <code>AudioListener2D</code>. \n\nЕсли в текущей области просмотра нет активного <code>AudioListener2D</code>, в качестве точки прослушивания звука будет использоваться центр экрана. Для работы <code>AudioListener2D</code> должен находиться внутри <code>SceneTree</code>.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods AudioListener2D</code>",
                "\n\n🔴AudioListener3D:",
                "\n<blockquote expandable>После добавления в дерево сцены и активации с помощью <code>make_current</code> этот узел будет определять местоположение, из которого слышны звуки. Это можно использовать для прослушивания звуков из места, отличного от <code>Camera3D</code>.</blockquote>",
                "\n<b>Методы объекта:</b> <code>/methods AudioListener3D</code>",
                "\n\n⚪️AudioStreamPlayer:",
                "\n<blockquote expandable>Узел <code>AudioStreamPlayer</code> воспроизводит аудиопоток непозиционно. Он идеально подходит для пользовательских интерфейсов, меню или фоновой музыки.Если вам нужно воспроизвести звук в определённой точке, используйте вместо этого <code>AudioStreamPlayer2D</code> или <code>AudioStreamPlayer3D</code>.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props AudioListener</code>",
                "\n<b>Методы объекта:</b> <code>/methods AudioListener</code>",
                "\n\n🔵AudioStreamPlayer2D:",
                "\n<blockquote expandable>Узел <code>AudioStreamPlayer2D</code> воспроизводит аудиопоток в центре экрана. <b>Примечание: </b>Примечание. Скрытие узла <code>AudioStreamPlayer2D</code> не отключает его аудиовыход. Чтобы временно отключить аудиовыход <code>AudioStreamPlayer2D</code>, установите для <code>volume_db</code> очень низкое значение, например <code>-100</code> (это значение не слышно человеческому слуху).</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props AudioListener2D</code>",
                "\n<b>Методы объекта:</b> <code>/methods AudioListener2D</code>",
                "\n\n🔴AudioStreamPlayer3D:",
                "\n<blockquote expandable>Узел <code>AudioStreamPlayer3D</code> воспроизводит аудио с позиционными звуковыми эффектами, основанными на относительном положении слушателя. Позиционные эффекты включают в себя затухание звука на расстоянии, направленность и эффект Доплера. Для большей реалистичности к удаленным звукам применяется фильтр нижних частот. Эту функцию можно отключить, установив значение <code>attenuation_filter_cutoff_hz</code> равным <code>20500</code>.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props AudioListener3D</code>",
                "\n<b>Методы объекта:</b> <code>/methods AudioListener3D</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_audiolistener2d.html"
        }
    },
    "50" : {
        "tags" : ["BUFFER", "БУФФЕР", "BACKBUFFERCOPY"],
        "body" : [
                "🔵Нода: <b>BackBufferCopy</b>\n",
                "\n<blockquote expandable>Узел для обратной буферизации отображаемого в данный момент экрана. Область, указанная в узле <code>BackBufferCopy</code>, буферизуется содержимым экрана, который она охватывает, или всего экрана в зависимости от параметра <code>copy_mode</code>. Доступ к ней можно получить в шейдерных скриптах с помощью текстуры экрана (т. е. унифицированного сэмплера с <code>hint_screen_texture</code>).\n\n<b>Примечание:</b> Поскольку этот узел наследуется от <code>Node2D</code> (а не от <code>Control</code>), привязки и поля не будут применяться к дочерним узлам, производным от <code>Control</code>. Это может вызвать проблемы при изменении размера окна. Чтобы избежать этого, добавляйте узлы, производные от <code>Control</code>, как братьев и сестёр к узлу <code>BackBufferCopy</code>, а не как дочерние элементы.</blockquote>",
                "\n<b>Свойства объекта:</b> <code>/props BackBufferCopy</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_backbuffercopy.html"
        }
    },
    "51" : {
        "tags" : ["BASEBUTTON", "БАЗОВАЯ КНОПКА"],
        "body" : [
                "🟢Нода: <b>BaseButton</b>\n",
                "\n<blockquote expandable><code>BaseButton</code> — это абстрактный базовый класс для кнопок графического интерфейса. Сам по себе он ничего не отображает.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props BaseButton</code>",
                "\n<b>Методы объекта:</b> <code>/methods BaseButton</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_basebutton.html"
        }
    },
    "52" : {
        "tags" : ["BONE", "КОСТИ"],
        "body" : [
                "🔵Нода: <b>Bone2D</b>\n",
                "\n<blockquote expandable>Иерархию <code>Bone2D</code> можно привязать к <code>Skeleton2D</code> для управления и анимации других узлов <code>Node2D</code>. Узлы <code>Bone2D</code> и <code>Skeleton2D</code> можно использовать для анимации 2D-моделей, созданных с помощью редактора UV-развертки <code>Polygon2D</code>. У каждой кости есть преобразование состояния покоя, к которому можно вернуться с помощью <code>apply_rest</code>. Эти состояния покоя относятся к родительскому элементу кости. Если в редакторе вы можете задать позу покоя для всего скелета с помощью пункта меню, то в коде вам нужно перебрать кости, чтобы задать для них индивидуальные позы покоя.</blockquote>",
                "\n\n<b>Свойства объекта:</b> <code>/props Bone2D</code>",
                "\n<b>Методы объекта:</b> <code>/methods Bone2D</code>"
            ],
        "button" : {
            "text" : "См. в документации:",
            "link" : "https://docs.godotengine.org/ru/4.x/classes/class_bone2d.html"
        }
    }
}